// Copyright Epic Games, Inc. All Rights Reserved.
#include "InterchangeWorkerHandler.h"

#include "InterchangeCommands.h"
#include "InterchangeDispatcher.h"
#include "InterchangeDispatcherConfig.h"
#include "InterchangeDispatcherLog.h"

#include "HAL/FileManager.h"
#include "HAL/PlatformProcess.h"
#include "Misc/Paths.h"
#include "Sockets.h"
#include "SocketSubsystem.h"

namespace UE
{
	namespace Interchange
	{

		static FString GetWorkerExecutablePath()
		{
			static FString ProcessorPath = [&]()
			{
				FString Path = FPaths::Combine(FPaths::EngineDir(), TEXT("Binaries"));

#if PLATFORM_MAC
				Path = FPaths::Combine(Path, TEXT("Mac/InterchangeWorker"));
#elif PLATFORM_LINUX
				Path = FPaths::Combine(Path, TEXT("Linux/InterchangeWorker"));
#elif PLATFORM_WINDOWS
#if UE_BUILD_DEBUG
				Path = FPaths::Combine(Path, TEXT("Win64/InterchangeWorker-Win64-Debug.exe"));
#else //#if UE_BUILD_DEBUG
				Path = FPaths::Combine(Path, TEXT("Win64/InterchangeWorker.exe"));
#endif //#else UE_BUILD_DEBUG
#endif //#elif PLATFORM_WINDOWS
				if (!FPaths::FileExists(Path))
				{
					UE_LOG(LogInterchangeDispatcher, Warning, TEXT("InterchangeWorker executable not found. Expected location: %s"), *FPaths::ConvertRelativePathToFull(ProcessorPath));
				}
				return Path;
			}();

			return ProcessorPath;
		}

		FInterchangeWorkerHandler::FInterchangeWorkerHandler(FInterchangeDispatcher& InDispatcher, FString& InResultFolder)
			: Dispatcher(InDispatcher)
			, WorkerState(EWorkerState::Uninitialized)
			, ErrorState(EWorkerErrorState::Ok)
			, ResultFolder(InResultFolder)
			, bShouldTerminate(false)
		{
			//Use a randomGuid to generate unique name
			int32 UniqueID = (FPlatformTime::Cycles64() & 0x00000000EFFFFFFF);
			ThreadName = FString(TEXT("InterchangeWorkerHandler_")) + FString::FromInt(UniqueID);
			IOThread = FThread(*ThreadName, [this]() { Run(); });
		}

		FInterchangeWorkerHandler::~FInterchangeWorkerHandler()
		{
			StopBlocking();
		}

		void FInterchangeWorkerHandler::StartWorkerProcess()
		{
			uint32 WorkerProcessId = 0;

			ensure(ErrorState == EWorkerErrorState::Ok);
			FString ProcessorPath = GetWorkerExecutablePath();
			if (FPaths::FileExists(ProcessorPath))
			{
				int32 ListenPort = NetworkInterface.GetListeningPort();
				if (ListenPort == 0)
				{
					ErrorState = EWorkerErrorState::ConnectionFailed_NotBound;
					return;
				}

				FString CommandToProcess;

				// Manually set worker BaseDir of worker process (as automatic deduction is broken in our case,
				// probably due to the abuse of ExeBinariesSubFolder in InterchangeWorker.Target.cs)
				// This fixes paths of logs generated by the worker.
				FString BaseDir = FPlatformProcess::BaseDir();
				CommandToProcess += TEXT(" -basedir=\"") + BaseDir + TEXT("\"");
				CommandToProcess += TEXT(" -ServerPID ") + FString::FromInt(FPlatformProcess::GetCurrentProcessId());
				CommandToProcess += TEXT(" -ServerPort ") + FString::FromInt(ListenPort);
				CommandToProcess += TEXT(" -InterchangeDispatcherVersion \"") + DispatcherCommandVersion::ToString() + TEXT('"');
				CommandToProcess += TEXT(" -ResultFolder \"") + ResultFolder + TEXT("\"");
				UE_LOG(LogInterchangeDispatcher, Verbose, TEXT("CommandToProcess: %s"), *CommandToProcess);
				WorkerHandle = FPlatformProcess::CreateProc(*ProcessorPath, *CommandToProcess, true, false, false, &WorkerProcessId, 0, nullptr, nullptr);
			}

			if (!WorkerHandle.IsValid() || !FPlatformProcess::IsProcRunning(WorkerHandle) || !FPlatformProcess::IsApplicationRunning(WorkerProcessId))
			{
				ErrorState = EWorkerErrorState::WorkerProcess_CantCreate;
				return;
			}
		}

		void FInterchangeWorkerHandler::ValidateConnection()
		{
			if (!NetworkInterface.IsValid())
			{
				UE_LOG(LogInterchangeDispatcher, Error, TEXT("NetworkInterface lost"));
				WorkerState = EWorkerState::Closing;
				ErrorState = EWorkerErrorState::ConnectionLost;
			}
			else if (WorkerHandle.IsValid() && !FPlatformProcess::IsProcRunning(WorkerHandle))
			{
				UE_LOG(LogInterchangeDispatcher, Error, TEXT("Worker lost"));
				WorkerState = EWorkerState::Closing;
				ErrorState = EWorkerErrorState::WorkerProcess_Lost;
			}
		}

		void FInterchangeWorkerHandler::Run()
		{
			WorkerState = EWorkerState::Uninitialized;
			RunInternal();
			WorkerState = EWorkerState::Terminated;
			UE_CLOG(ErrorState != EWorkerErrorState::Ok, LogInterchangeDispatcher, Warning, TEXT("Handler ended with error: %s"), EWorkerErrorStateAsString(ErrorState));
		}

		void FInterchangeWorkerHandler::RunInternal()
		{
			while (IsAlive())
			{
				switch (WorkerState)
				{
					case EWorkerState::Uninitialized:
					{
						ErrorState = EWorkerErrorState::Ok;

						StartWorkerProcess();

						if (ErrorState != EWorkerErrorState::Ok)
						{
							WorkerState = EWorkerState::Terminated;
							break;
						}

						// The Accept() call on the server blocks until a connection is initiated from a client
						static const FString SocketDescription = TEXT("InterchangeWorkerHandler");
						if (!NetworkInterface.Accept(SocketDescription, Config::AcceptTimeout_s))
						{
							ErrorState = EWorkerErrorState::ConnectionFailed_NoClient;
						}
						else
						{
							CommandIO.SetNetworkInterface(&NetworkInterface);
						}

						if (ErrorState != EWorkerErrorState::Ok)
						{
							WorkerState = EWorkerState::Closing;
							break;
						}

						WorkerState = EWorkerState::Idle;
						break;
					}

					case EWorkerState::Idle:
					{
						// Fetch a new task
						ensureMsgf(CurrentTask.IsSet() == false, TEXT("We should not have a current task when fetching a new one"));
						CurrentTask = Dispatcher.GetNextTask();

						if (CurrentTask.IsSet())
						{
							FRunTaskCommand NewTask(CurrentTask.GetValue());

							if (CommandIO.SendCommand(NewTask, Config::SendCommandTimeout_s))
							{
								UE_LOG(LogInterchangeDispatcher, Verbose, TEXT("New task command sent"));
								WorkerState = EWorkerState::Processing;
							}
							else
							{
								// Signal that the Task was not processed
								TArray<FString> GarbageMessages;
								Dispatcher.SetTaskState(CurrentTask->Index, ETaskState::UnTreated, FString(), GarbageMessages);

								UE_LOG(LogInterchangeDispatcher, Error, TEXT("New task command issue"));
								WorkerState = EWorkerState::Closing;
								ErrorState = EWorkerErrorState::ConnectionLost_SendFailed;
							}
						}
						else if (bShouldTerminate)
						{
							UE_LOG(LogInterchangeDispatcher, Verbose, TEXT("Exit loop gracefully"));
							WorkerState = EWorkerState::Closing;
						}
						else
						{
							ValidateConnection();

							// consume
							if (TSharedPtr<ICommand> Command = CommandIO.GetNextCommand(Config::IdleLoopDelay))
							{
								ProcessCommand(*Command);
							}
						}

						break;
					}

					case EWorkerState::Processing:
					{
						if (TSharedPtr<ICommand> Command = CommandIO.GetNextCommand(Config::ProcessingLoopDelay))
						{
							ProcessCommand(*Command);

							bool bProcessingOver = CurrentTask.IsSet() == false;
							if (bProcessingOver)
							{
								WorkerState = bShouldTerminate ? EWorkerState::Closing : EWorkerState::Idle;
							}
						}
						else
						{
							ValidateConnection();
							if (ErrorState == EWorkerErrorState::WorkerProcess_Lost)
							{
								if (CurrentTask.IsSet())
								{
									TArray<FString> GarbageMessages;
									Dispatcher.SetTaskState(CurrentTask->Index, ETaskState::ProcessFailed, FString(), GarbageMessages);
									CurrentTask.Reset();
								}

								WorkerState = EWorkerState::Closing;
							}
						}
						break;
					}

					case EWorkerState::Closing:
					{
						// try to close the process gracefully
						if (WorkerHandle.IsValid())
						{
							bool CloseByCommand = Config::CloseProcessByCommand && CommandIO.IsValid() && FPlatformProcess::IsProcRunning(WorkerHandle);

							bool bClosed = false;
							if (CloseByCommand)
							{
								FTerminateCommand Terminate;
								CommandIO.SendCommand(Terminate, 0);

								for (int32 i = 0; i < int32(10. * Config::TerminateTimeout_s); ++i)
								{
									if (!FPlatformProcess::IsProcRunning(WorkerHandle))
									{
										bClosed = true;
										break;
									}
									FPlatformProcess::Sleep(0.1);
								}
							}

							if (!bClosed)
							{
								FPlatformProcess::TerminateProc(WorkerHandle, true);
							}
						}

						// Process commands still in input queue
						CommandIO.Disconnect(0);
						while (TSharedPtr<ICommand> Command = CommandIO.GetNextCommand(0))
						{
							ProcessCommand(*Command);
						}

						WorkerState = EWorkerState::Terminated;
						break;
					}

					default:
					{
						ensureMsgf(false, TEXT("missing case handling"));
					}
				}
			}
		}

		void FInterchangeWorkerHandler::Stop()
		{
			bShouldTerminate = true;
		}

		void FInterchangeWorkerHandler::StopBlocking()
		{
			Stop();
			if (IOThread.IsJoinable())
			{
				IOThread.Join();
			}
		}

		bool FInterchangeWorkerHandler::IsAlive() const
		{
			return WorkerState != EWorkerState::Terminated;
		}

		void FInterchangeWorkerHandler::ProcessCommand(ICommand& Command)
		{
			switch (Command.GetType())
			{
				case ECommandId::Ping:
					ProcessCommand(StaticCast<FPingCommand&>(Command));
					break;

				case ECommandId::NotifyEndTask:
					ProcessCommand(StaticCast<FCompletedTaskCommand&>(Command));
					break;

				default:
					break;
			}
		}

		void FInterchangeWorkerHandler::ProcessCommand(FPingCommand& PingCommand)
		{
			UE::Interchange::FBackPingCommand BackPing;
			CommandIO.SendCommand(BackPing, 0);
		}

		void FInterchangeWorkerHandler::ProcessCommand(FCompletedTaskCommand& CompletedTaskCommand)
		{
			if (!CurrentTask.IsSet())
			{
				return;
			}

			Dispatcher.SetTaskState(CurrentTask->Index, CompletedTaskCommand.ProcessResult, CompletedTaskCommand.JSonResult, CompletedTaskCommand.JSonMessages);
			CurrentTask.Reset();
		}

		const TCHAR* FInterchangeWorkerHandler::EWorkerErrorStateAsString(EWorkerErrorState Error)
		{
			switch (Error)
			{
				case EWorkerErrorState::Ok: return TEXT("Ok");
				case EWorkerErrorState::ConnectionFailed_NotBound: return TEXT("Connection failed (socket not bound)");
				case EWorkerErrorState::ConnectionFailed_NoClient: return TEXT("Connection failed (No connection from client)");
				case EWorkerErrorState::ConnectionLost: return TEXT("Connection lost");
				case EWorkerErrorState::ConnectionLost_SendFailed: return TEXT("Connection lost (send failed)");
				case EWorkerErrorState::WorkerProcess_CantCreate: return TEXT("Worker process issue (cannot create worker process)");
				case EWorkerErrorState::WorkerProcess_Lost: return TEXT("Worker process issue (worker lost)");
				default: return TEXT("unknown");
			}
		}

	} //ns Interchange
}//ns UE
